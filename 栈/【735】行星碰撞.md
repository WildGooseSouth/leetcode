### [行星碰撞](https://leetcode-cn.com/problems/asteroid-collision/)

#### 题目描述

给定一个整数数组 asteroids，表示在同一行的行星。

对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。

找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。

```c
输入：asteroids = [5,10,-5]
输出：[5,10]
解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。

输入：asteroids = [8,-8]
输出：[]
解释：8 和 -8 碰撞后，两者都发生爆炸。
```

#### 题目分析

题目中给出了碰撞规则，根据该规格模拟即可，借助单调栈方法。

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* asteroidCollision(int* asteroids, int asteroidsSize, int* returnSize){
    int i, top, diff;
    int* stack = (int *)malloc(sizeof(int) * asteroidsSize);
    memset(stack, 0, sizeof(int) * asteroidsSize);

    int *res = (int *)malloc(sizeof(int) * asteroidsSize);
    memset(res, 0, sizeof(int) * asteroidsSize);

    top = -1;
    for (i = 0; i < asteroidsSize; i++) {
        diff = 1;
        // 比较新加入的元素和栈顶之间大小
        while (top > -1 &&
              asteroids[i] < 0 && asteroids[stack[top]] > 0) {
              diff = abs(asteroids[i]) - abs(asteroids[stack[top]]);

              if (diff > 0) {
                  top--;
              } else {
                  break;
              }
        }
		
        // 两者相等，新元素不入栈，头部出栈
        if (diff == 0) {
            top--;
        }

        if (diff > 0) {
            top++;
            stack[top] = i;
        }
    }

    *returnSize = top + 1;
    for (i = 0; i <= top; i++) {
        res[i] = asteroids[stack[i]];
    }

    if (stack) {
        free(stack);
    }

    return res;
}
```

