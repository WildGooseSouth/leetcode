### [表现良好的最长时间段](https://leetcode-cn.com/problems/longest-well-performing-interval/)

#### 题目描述

给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。

我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。

所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。

请你返回「表现良好时间段」的最大长度。

```c
输入：hours = [9,9,6,0,6,6,9]
输出：3
解释：最长的表现良好时间段是 [9,9,6]。
```

#### 题目分析

题目要计算满足给定条件的最大长度区间，首先想到的是暴力求解方法。这里计算一段区间是否满足，为了方便计算，需要用到【前缀和】方法，先将给出的工作时间表hours转化为1和-1的数组，然后计算数组的前缀和，代码如下：

```c
int longestWPI(int* hours, int hoursSize){
    int i, j, hour, res;

    int* sum = (int *)malloc(sizeof(int) * (hoursSize + 1));
    memset(sum, 0, sizeof(int) * (hoursSize + 1));

    //构造前缀和
    for (i = 1; i <= hoursSize; i++) {
        hour = hours[i - 1] > 8 ? 1 : -1;
        sum[i] =  hour + sum[i - 1];
    }

    res = 0;
    for (i = 0; i <= hoursSize; i++) {
        for (j = i + 1; j <= hoursSize; j++) {
            if (sum[j] - sum[i] > 0) {
                // 这里的区间条件是(left, right]
                res = fmax(res, j - i);
            }
        }
    }

    return res;
}
```

上面的求解方法简单明了，执行起来必然是超时失败。进一步思考，如果区间(i, j]满足条件，那么中间的值不需要尝试判断，因为最大区间长度必然是 j - i，这里从右往左遍历，代码如下

```c
![1](C:\Users\postg\Desktop\1.JPG)int longestWPI(int* hours, int hoursSize){
    int i, j, hour, res;

    int* sum = (int *)malloc(sizeof(int) * (hoursSize + 1));
    memset(sum, 0, sizeof(int) * (hoursSize + 1));

    //构造前缀和
    for (i = 1; i <= hoursSize; i++) {
        hour = hours[i - 1] > 8 ? 1 : -1;
        sum[i] =  hour + sum[i - 1];
    }

    res = 0;
    for (i = 0; i <= hoursSize; i++) {
        for (j = hoursSize; j > i; j--) {
            if (sum[j] - sum[i] > 0) {
                res = fmax(res, j - i);
                break;
            }
        }
    }

    return res;
}
```

调整遍历顺序后，提交可以通过，执行时间仍然较长。

结合前面分析可以看出，在使用前缀和之后，原题目已经转化成从右往左遍历，找到两个坐标点，使得它们的差值大于0，在所有满足条件的坐标点中，寻找宽度最大的两个。考虑使用单调栈方法，

* 从左往右遍历，构造一个单调递减数组，作为备选的左边端点。选择递减的原因是，如果右边的值是递增的满足条件，那么左边较小的值必然满足，且左边端点的宽度必然更大。
* 从右往左遍历，如果右边端点值大于当前左端点值，左端点继续往左边移动；否则，右端点往左移动

```c
// 利用哨兵，构造前缀和
int longestWPI(int* hours, int hoursSize){
    int i, hour, res, top;

    int* sum = (int *)malloc(sizeof(int) * (hoursSize + 1));
    memset(sum, 0, sizeof(int) * (hoursSize + 1));

    int* stack = (int *)malloc(sizeof(int) * (hoursSize + 1));
    memset(stack, 0, sizeof(int) * (hoursSize + 1));

    //构造前缀和
    for (i = 1; i <= hoursSize; i++) {
        hour = hours[i - 1] > 8 ? 1 : -1;
        sum[i] =  hour + sum[i - 1];
    }

    // 从左往右遍历，构造单调递减数组
    top = 0;
    for (i = 1; i <= hoursSize; i++) {
        if (sum[i] < sum[stack[top]]) {
            top++;
            stack[top] = i;
        }
    }

    // 从右往左遍历
    res = 0;
    for (i = hoursSize; i >= 0; i--) {
        while (top > -1 && sum[i] > sum[stack[top]]) {
            res = fmax(res, i - stack[top]);
            top--;
        }

        if (top == -1) {
            break;
        }
    }

    return res;
}
```

