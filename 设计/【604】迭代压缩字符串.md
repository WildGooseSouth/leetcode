#### [迭代压缩字符串](https://leetcode-cn.com/problems/design-compressed-string-iterator/)

#### 题目描述

对于一个压缩字符串，设计一个数据结构，它支持如下两种操作： next 和 hasNext。

给定的压缩字符串格式为：每个字母后面紧跟一个正整数，这个整数表示该字母在解压后的字符串里连续出现的次数。

next() - 如果压缩字符串仍然有字母未被解压，则返回下一个字母，否则返回一个空格。
	    hasNext() - 判断是否还有字母仍然没被解压。

```c
StringIterator iterator = new StringIterator("L1e2t1C1o1d1e1");

iterator.next(); // 返回 'L'
iterator.next(); // 返回 'e'
iterator.next(); // 返回 'e'
iterator.next(); // 返回 't'
iterator.next(); // 返回 'C'
iterator.next(); // 返回 'o'
iterator.next(); // 返回 'd'
iterator.hasNext(); // 返回 true
iterator.next(); // 返回 'e'
iterator.hasNext(); // 返回 false
iterator.next(); // 返回 ' '
```

#### 题目分析

结构体中记录需要压缩的总元素个数以及当前位置、每个待解压元素的个数信息。

```C
typedef struct {
    char *str;
    int  *pos;
    int current;
    int count;
} StringIterator;

StringIterator* stringIteratorCreate(char * compressedString) {
    int i;
    int tot = 0;
    int start, number;

    int len = strlen(compressedString);
    StringIterator *res = (StringIterator*)malloc(sizeof(StringIterator));
    res->str = (char *)malloc(sizeof(char) * (len  + 1));
    memset(res->str, 0, sizeof(char) * (len  + 1));
    res->pos = (int *)malloc(sizeof(int) * (len + 1));
    memset(res->pos, -1, sizeof(int) * (len  + 1));
    res->count = 0;

    start = 0;
    while (start < len - 1) {
        res->str[tot] = compressedString[start];
        number = 0;
        for (i = start + 1; i < len; i++) {
            if (compressedString[i] > '9') {
                break;
            }
            number = 10 * number + compressedString[i] - '0';
        }

        start = i;
        res->pos[tot++] = number;
        res->count += number;
    }

    res->current = 0;

    return res;    
}

char stringIteratorNext(StringIterator* obj) {
    int cur = obj->current;

    if (obj->pos[cur] == 0) {
        cur++;
        obj->current = cur;
    } 

    if (obj->count == 0) {
        return ' ';
    }

    obj->count--;
    obj->pos[cur]--;
    return obj->str[cur];
}

bool stringIteratorHasNext(StringIterator* obj) {
    if (obj->count == 0) {
        return false;
    }

    return true;
}

void stringIteratorFree(StringIterator* obj) {
    if (obj->str) {
        free(obj->str);
    }

    if (obj->pos) {
        free(obj->pos);
    }

    obj->current = 0;
    obj->count = 0;

    free(obj);
}
```

